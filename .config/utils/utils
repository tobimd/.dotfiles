#!/usr/bin/zsh

# Get all git aliases from 'git' ohmyzsh plugin and print them
gitaliases() {
    result=""
    cache="$UTILS_HOME/cached-aliases"

    # result=$(curl https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/plugins/git/README.md 2>/dev/null | awk -F '\|' '{if(match($2, /----/) == 0) {$1 = ""; $NF=""; gsub(/\\ /, "\|"); print $0}}' | perl -0777 -pe 's/^(\s+)(.+?)(\n\n\n+.+)/${2}\n/sg' | egrep $1)
    
    if [[ ! -z "$1" ]]; then
        cat $cache | egrep $1 
    else
        cat $cache
    fi
}

# Start ssg-agent
ssh_start() { eval "$(ssh-agent -s)"  }
ssh_keygen() { ssh-keygen -t ed25519 -C "$1" }

# Wrapper for nvim, to open symlinks
nvim() {
  args=()

  for i in $@; do
    if [[ -h $i ]]; then
      args+=`readlink $i`
    else
      args+=$i
    fi
  done

  $NEOVIM_HOME -p "${args[@]}"
}

prompt-mode() {
    autoload -U colors && colors

    typeset -A prompts=(
        [l]="singleline"
        [lv]="singleline_verbose"
        [p]="pure"
        [hp]="half_pure"
        [m]="multiline"
        [s]="split"
        [ls]="singleline_split"
    )

    if [[ ! -z "$1" ]]; then
        mode=$1
        match=""

        for short long in "${(@kv)prompts}"; do
            if [[ "$mode" == "$short" || "$mode" == "$long" ]]; then
                match="$long"
            fi
        done

        if [[ "$match" != "" ]]; then
            str_repl="s/TYPEWRITTEN_PROMPT_LAYOUT=.+/TYPEWRITTEN_PROMPT_LAYOUT=\"$match\"/"

            if [[ "$OSTYPE" == "darwin"* ]]; then
                gsed -i -r "$str_repl" $ZSHRC_ENV
            elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
                sed -i -r "$str_repl" $ZSHRC_ENV
            fi

            echo "Changing prompt mode to \"$fg_bold[blue]$match$fg_no_bold[default]\".\n"
            source $ZSHRC_HOME

        else
            echo "Could not resolve prompt mode: \"$mode\"."
        fi

    else
        echo "Please choose the prompt mode to use:"

        for short long in "${(@kv)prompts}"; do
            if [[ "$TYPEWRITTEN_PROMPT_LAYOUT" == "$long" ]]; then
                echo "      * $fg_bold[blue]${(r:20:)long} $fg_no_bold[default]($fg_bold[blue] ${(r:3:)short}$fg_no_bold[default])"
            else
                echo "\t${(r:20:)long} ( ${(r:3:)short})"
            fi
        done
        echo ""
    fi
}

repstring() {
    local input=$1
    local count=$2

    printf -v string '%*s' "$count"
    printf '%s\n' "${string// /$input}"
}

clean() {
    echo $(repstring "\n" 500)
    clear
}

venv-start() {
    local dir="$1"

    if [[ -z "$dir" ]]; then
        dir="$PWD"
    fi

    if [[ -x "$dir/bin" && -a "$dir/bin/activate" ]]; then
        source "$dir/bin/activate"

    elif [[ -a "$dir/activate" ]]; then
        source "$dir/activate"

    else
        echo "Couldn't find \"/bin/activate\" directory to initiate virtual environment."
    fi
}

git() {
    if [[ "$PWD" == "$HOME" ]]; then
        if [[ "$1" == "clone" ]];then
            $GIT_HOME "$@"

        elif [[ "$1" == "add" && "$2" == "--all" ]]; then
            $GIT_HOME --git-dir="$HOME/.dotfiles/" --work-tree="$HOME" add --update

        elif [[ "$1" == "status" ]]; then
            shift
            $GIT_HOME --git-dir="$HOME/.dotfiles/" --work-tree="$HOME" status -uno "$@"

        else            
            $GIT_HOME --git-dir="$HOME/.dotfiles/" --work-tree="$HOME" "$@"
        fi

    else
        $GIT_HOME "$@"
    fi
}

config() {
   
    if [[ ! -z $(which tput 2> /dev/null) ]]; then
        local reset=$(tput sgr0)
        local bold=$(tput bold)
        local red=$(tput setaf 1)
        local green=$(tput setaf 2)
        local yellow=$(tput setaf 3)
        local blue=$(tput setaf 4)
        local magenta=$(tput setaf 5)
        local cyan=$(tput setaf 6)
    else
        autoload -U colors && colors

        local reset="%{$reset_color%}"
        local bold="%{$bold_color%}"
        local red="%{$fg[red]%}"
        local green="%{$fg[green]%}"
        local yellow="%{$fg[yellow]%}"
        local blue="%{$fg[blue]%}"
        local magenta="%{$fg[magenta]%}"
        local cyan="%{$fg[cyan]%}"
    fi

    local config_files_dir="$UTILS_HOME/configfiles"
    local reserved=".config-help"
    local error_msg="none"
    local cmd_mode="none"
    local flag_order=()

    typeset -A flags=(
        force     0
        link      0
        no_suffix 0
        verbose   0
    )

    typeset -A error_list=(
        [AE0]="(${yellow}ArgumentError$reset) No arguments were given"
        [AE1]="(${yellow}ArgumentError$reset) Missing argument"
        [AE2]="(${yellow}ArgumentError$reset) Too many arguments were used"
        [AE3]="(${yellow}ArgumentError$reset) Unknown argument or shortcut file"
        [CE0]="(${yellow}ConfigError$reset) Shortcut doesn't exist or wasn't found"
        [CE1]="(${yellow}ConfigError$reset) File doesn't exist or wasn't found"
        [CE2]="(${yellow}ConfigError$reset) Can't use \"$cyan$reserved$reset\" as the shortcut's name because it's reserved"
        [CE3]="(${yellow}ConfigError$reset) Name is already being used"
        [FE0]="(${yellow}FlagError$reset) Unknown flag"
        [FE1]="(${yellow}FlagError$reset) Can't use flag"
    )

    tb_info()       { echo "[ ${cyan}config${reset} ]: $@"            ;          }
    tb_warn()       { echo "[ ${yellow}config${reset} ]: $@"          ;          }
    tb_error()      { echo "[ ${red}config${reset} ]: $@"             ; echo ""; }
    tb_success()    { echo "[ ${green}config${reset} ]: $@"           ; echo ""; }
    tb_print_help() { printf "$(cat "$config_files_dir/.config-help")"; echo ""; }

    # Create directory if it doesn't exist yet
    if [[ ! -x "$config_files_dir" || ! -f "$config_files_dir/$reserved" ]]; then
        mkdir -p $config_files_dir
        echo 'usage: config COMMAND [OPTION...] [ARGS...]
  or:  config NAME

Create shortcuts for files that can later be opened using
the NAME of the saved shortcut.

 -f, --force    Do not prompt
 -v, --verbose  Explain what is being done
 -h, --help     Display this help message and exit. Same as
                using \033[1mhelp\033[0m as a command.
 -l, --list     Output list of all shortcuts saved. Same as
                using \033[1mlist\033[0m as a command.

\033[1madd\033[0m, \033[1m-a\033[0m, \033[1m--add\033[0m
    usage: config add [OPTION...] FILE [NAME]

    Create a shortcut for a file.

    -x, --no-suffix  Remove suffix from FILE if no NAME is
                     given.

    If NAME is not used, then a symlink is created with
    FILE instead (directories are not included, only the 
    file name).

\033[1mremove\033[0m, \033[1mrm\033[0m, \033[1m-r\033[0m, \033[1m--remove\033[0m
    usage: config remove [OPTION...] NAME
    
    Remove an existing shortcut from the list.

\033[1medit\033[0m, \033[1m-e\033[0m, \033[1m--edit\033[0m
    usage: config edit [OPTION...] NAME NEW_NAME
      or:  config edit [OPTION...] [-k|--link] NAME NEW_LINK
        
    Change some aspect of saved shortcuts.

    -k, --link  Specifies for the existing shortcut, to
                redirect to a new location

\033[1m\033[3mexamples\033[0m:
    The following two commands create the same shortcut
    named "\033[3mfoo\033[0m" for the file "\033[3mfoo.txt\033[0m" that is located in
    the current directory.
        $ config add foo.txt foo
        $ config add -x foo.txt

    Change name of existing shortcut "\033[3mfoo\033[0m" to "\033[3mbar\033[0m"
        $ config edit foo bar

    Point existing "\033[3mbar\033[0m" shortcut to a new file called
    "\033[3mbaz.txt\033[0m" inside the Desktop folder
        $ config edit --link bar ~/Desktop/baz.txt

' >> "$config_files_dir/.config-help"
    fi
    
    # Find and remove optional arguments
    for arg in "$@"; do
        shift
        if [[ $arg[1] == "-" ]]; then
            # Short flag and long flag versions
            local sf="${arg:1:#arg}"
            local lf=""
            if [[ $sf[1] == "-" ]]; then; lf="${sf:1:#sf}"; fi

            if   [[ $lf == "remove" || $lf == "rm" || $sf == "r" ]]; then; flag_order+="r"
            elif [[ $lf == "add"       || $sf == "a" ]]; then; flag_order+="a"
            elif [[ $lf == "edit"      || $sf == "e" ]]; then; flag_order+="e"
            elif [[ $lf == "help"      || $sf == "h" ]]; then; flag_order+="h"
            elif [[ $lf == "list"      || $sf == "l" ]]; then; flag_order+="l"
            elif [[ $lf == "force"     || $sf == "f" ]]; then; flags[force]=1; flag_order+="f"
            elif [[ $lf == "link"      || $sf == "k" ]]; then; flags[link]=1;  flag_order+="k"
            elif [[ $lf == "no-suffix" || $sf == "x" ]]; then; flags[no_suffix]=1; flag_order+="x"
            elif [[ $lf == "verbose"   || $sf == "v" ]]; then; flags[verbose]=1;   flag_order+="v"
            else
                # Check if it's a joint group of flags
                
                if [[ $lf == "" ]]; then
                    sep_flags=(`echo $sf | grep -o . `)
                    for _f in "${sep_flags[@]}"; do
                        if   [[ $_f == "r" ]]; then; flag_order+="r"
                        elif [[ $_f == "a" ]]; then; flag_order+="a"
                        elif [[ $_f == "e" ]]; then; flag_order+="e"
                        elif [[ $_f == "h" ]]; then; flag_order+="h"
                        elif [[ $_f == "l" ]]; then; flag_order+="l"
                        elif [[ $_f == "f" ]]; then; flags[force]=1; flag_order+="f"
                        elif [[ $_f == "k" ]]; then; flags[link]=1;  flag_order+="k"
                        elif [[ $_f == "x" ]]; then; flags[no_suffix]=1; flag_order+="x"
                        elif [[ $_f == "v" ]]; then; flags[verbose]=1;   flag_order+="v"
                        else
                            tb_error $error_list[FE0] "\"$cyan$arg$reset\""
                            return 3
                        fi
                    done
                else
                    tb_error $error_list[FE0] "\"$cyan$arg$reset\""
                    return 3
                fi
            fi

        else
            set -- "$@" $arg
        fi
    done


    if [[ "${#flag_order}" != "0" ]]; then
        for _f in "${flag_order[@]}"; do
            if   [[ $_f == "a" ]]; then; cmd_mode="add"; break
            elif [[ $_f == "e" ]]; then; cmd_mode="edit"; break
            elif [[ $_f == "r" ]]; then; cmd_mode="remove"; break
            elif [[ $_f == "h" ]]; then; cmd_mode="help"; break
            elif [[ $_f == "l" ]]; then; cmd_mode="list"; break
            fi
        done
    fi

    # Check if there are any arguments at all
    if [[ ! -z "$1" || $cmd_mode != "none" ]]; then

        if [[ $cmd_mode == "none" ]]; then
            cmd_mode=$1; shift
        fi

        # ADD COMMAND =========================================================
        if [[ "$cmd_mode" == "add" ]]; then

            # ERROR CHECKS
            # *** No file argument was given
            if [[ -z "$1" ]]; then
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[AE1] "\"${cyan}file$reset\""
                    tb_print_help
                    return 1
                fi

                return 0
            fi
            
            local file="$(realpath -m $1)"
            local name="$2"
            local bn_file="$(basename $file)"

            # *** File doesn't exist
            if [[ ! -f $file ]]; then
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[CE1] "\"$cyan$file$reset\""
                    return 2
                fi

                if (( $flags[verbose] == 1 )); then
                    tb_warn $error_list[CE1] "\"$cyan$file$reset\""
                fi
                return 0

            # *** File name is reserved
            elif [[ $name == $reserved || ($bn_file == $reserved && -z $name) ]]; then
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[CE2][1]
                    return 2
                fi

                if (( $flags[verbose] == 1 )); then
                    tb_warn $error_list[CE2][1]
                fi
                return 0

            # *** More arguments than needed were used
            elif [[ ! -z "$3" ]]; then
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[AE2][1]
                    tb_print_help
                    return 1
                fi

                if (( $flags[verbose] == 1 )); then
                    tb_warn $error_list[AE2][1]
                fi
                return 0
                
            # *** Symlink already exists in config directory, and no name was given (not using force)
            elif [[ -h "$config_files_dir/${file:t}" && -z $name ]]; then
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[CE3] "\"$cyan${file:t}$reset\""
                    return 2
                fi

                if (( $flags[verbose] == 1 )); then
                    tb_warn $error_list[CE3][1]
                fi
                return 0

            # *** name is used as well as no-suffix
            elif [[ ! -z $name && "$flags[no_suffix]" == "1" ]]; then
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[FE1] "$yellow--no-suffix$reset when argument ${cyan}name$reset is used (\"$cyan$name$reset\")"
                    tb_print_help
                    return 3
                fi

                if (( $flags[verbose] == 1 )); then
                    tb_warn $error_list[FE1] "$yellow--no-suffix$reset when argument ${cyan}name$reset is used (\"$cyan$name$reset\")"
                fi
                return 0
                
            fi
            
            local link_name=$bn_file

            # Symlink <file> normally and rename later if necessary
            # If no name is given and no-suffix is used, then link name will be the file without suffix
            if [[ -z $name && "$flags[no_suffix]" == "1" ]]; then
                link_name=${link_name%.*}
            elif [[ ! -z $name ]]; then
                link_name=$name
            fi

            ln -s $file "$config_files_dir/$link_name"
            if (( $flags[verbose] == 1 )); then
                tb_info "Created symlink for $cyan$file$reset called $cyan$link_name$reset."
            fi
        
            if (( $flags[force] == 0 )); then
                tb_success "Successfully created config file \"$cyan$link_name$reset\" for $file."
            fi
            return 0
            
           
        # REMOVE COMMAND =======================================================
        elif [[ "$cmd_mode" == "rm" || "$cmd_mode" == "remove" ]]; then
            
            local name="$1"
            local file="$config_files_dir/$name"          
            
            # ERROR CHECKS
            # *** Symlink <name> does not exist (and not using force)
            if [[ ! -f $file ]]; then
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[CE1] "\"$cyan$file$reset\""
                    return 2
                fi

                if (( $flags[verbose] == 1 )); then
                    tb_warn $error_list[CE1] "\"$cyan$file$reset\""
                fi
                return 0

            # *** More arguments than needed were used
            elif [[ ! -z "$2" ]]; then
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[AE2][1]
                    tb_print_help
                    return 1
                fi

                if (( $flags[verbose] == 1 )); then
                    tb_warn $error_list[AE2][1]
                fi
                return 0
            fi
            
            rm $file
            
            if (( $flags[force] == 0 )); then
                tb_success "Successfully removed config \"${cyan}$name${reset}\"."
            fi
            return 0

        # EDIT COMMAND ========================================================
        elif [[ "$cmd_mode" == "edit" ]]; then

            local old_name="$1"
            local new_name="$2"
            
            local old_file="$config_files_dir/$old_name"
            local new_file="$config_files_dir/$new_name"

            if (( $flags[link] == 1 )); then
                new_file="$(realpath -m $new_name)"
            fi            
            
            # ERROR CHECKS
            # *** Symlink <name> does not exist (and not using force)
            if [[ ! -f $old_file ]]; then
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[CE1] "\"$cyan$old_file$reset\""
                    return 2
                fi

                if (( $flags[verbose] == 1 )); then
                    tb_warn $error_list[CE1] "\"$cyan$old_file$reset\""
                fi
                return 0

            
            # *** Using --link, but <new file> does not exist
            elif [[ ! -f $new_file && "$flags[link]" == "1" ]]; then
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[CE1] "\"$cyan$new_file$reset\""
                    return 2
                fi
                return 0
            
            # *** File name is reserved
            elif [[ $name == $reserved || ($bn_file == $reserved && -z $name) ]]; then
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[CE2][1]
                    return 2
                fi

                if (( $flags[verbose] == 1 )); then
                    tb_warn $error_list[CE2][1]
                fi
                return 0

            # *** More arguments than needed were used
            elif [[ ! -z "$3" ]]; then
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[AE2][1]
                    tb_print_help
                    return 1
                fi

                if (( $flags[verbose] == 1 )); then
                    tb_warn $error_list[AE2][1]
                fi
                return 0
                
            fi
            
            # If using edit command for changing name of config file
            if [[ $flags[link] == "false" ]]; then
                mv "$old_file" "$new_file"

                local tmp_msg="Successfully renamed config \"${cyan}$old_name${reset}\" "
                tmp_msg+="to \"${cyan}$new_name${reset}\"."
                
            # If using edit command for redirecting existing config file to new location
            else
                rm "$old_file"
                ln -s "$new_file" "$old_file"

                local tmp_msg="Successfully redirected config \"${cyan}$old_name${reset}\" "
                tmp_msg+="to point to \"${cyan}$new_file${reset}\"."
            fi

            if (( $flags[force] == 0 )); then
                tb_success $tmp_msg
            fi
            return 0

        # HELP COMMAND ========================================================
        elif [[ $cmd_mode == "help" ]]; then
            tb_print_help
            return 0

        # LIST COMMAND ========================================================
        elif [[ $cmd_mode == "list" ]]; then
            local max_length=50
            local cur_length=0

            typeset -a bn_files

            for file in "$config_files_dir"/*(N); do
                local bn_file=$(basename $file)

                if [[ $bn_file != $reserved ]]; then
                    local len=$(expr length $bn_file)

                    if (( $len > $cur_length && $len < $max_length )); then
                        cur_length=$len
                    fi

                    bn_files+=$bn_file
                fi

            done


            for file in $bn_files; do
                if [[ $file != $reserved ]]; then
                    echo "  $green$bold${(r($cur_length)( ))file}$reset -> $(readlink "$config_files_dir/$file")"
                fi
            done
            echo ""
            return 0

        # TRY OPENING CONFIG FILE =============================================
        else
            local name=$cmd_mode
            local file="$config_files_dir/$name"

            if [[ -h $file ]]; then
                $NEOVIM_HOME $(readlink $file)
                return 0

            else
                if (( $flags[force] == 0 )); then
                    tb_error $error_list[AE3] "\"$cyan$file$reset\""
                    tb_print_help
                    return 1
                fi

                if (( $flags[verbose] == 1 )); then
                    tb_warn $error_list[AE3] "\"$cyan$file$reset\""
                fi
                return 0
            fi
        fi
    else 
        if (( $flags[force] == 0 )); then
            tb_error $error_list[AE0] "\"$cyan$file$reset\""
            tb_print_help
            return 1
        fi

        if (( $flags[verbose] == 1 )); then
            tb_warn $error_list[AE0] "\"$cyan$file$reset\""
        fi
        return 0
    fi
}
